<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>Cake Defense: Hybrid PWA v4_DEBUG</title>
  <link rel="manifest" href="manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="theme-color" content="#121212">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <link rel="icon" href="icons/icon-192.png">
  <style>
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;background:#121212;color:#f6f6f6;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    #wrapper{position:relative;display:flex;align-items:center;justify-content:center;height:100vh;width:100vw;overflow:hidden}
    #game{display:block;width:100vw;height:100vh;touch-action:none;outline:none;z-index:1}
    #ui{position:absolute;inset:0;z-index:2}
    #topbar{position:absolute;top:8px;left:8px;right:8px;display:flex;gap:8px;justify-content:space-between;align-items:center;font-weight:700;text-shadow:0 2px 4px rgba(0,0,0,.35)}
    .btn{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);padding:14px 18px;border:0;border-radius:12px;background:#4caf50;color:#fff;font-weight:700;font-size:18px}
    #hint{position:absolute;left:50%;bottom:16px;transform:translateX(-50%);opacity:.9;font-size:14px;text-align:center;max-width:92vw}
    .toast{position:absolute;left:50%;top:18%;transform:translateX(-50%);padding:10px 12px;background:#222;border-radius:10px;border:1px solid #3a3a3a;font-size:14px;opacity:0;transition:opacity .3s}
    .toast.show{opacity:1}
    #debug{position:absolute;left:8px;bottom:8px;z-index:3;background:rgba(0,0,0,.55);border:1px solid #444;border-radius:8px;padding:8px 10px;font:12px/1.3 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;max-width:92vw;white-space:pre-wrap}

  </style>
</head>
<body>
  <div id="wrapper">
    <canvas id="game" aria-label="Cake Defense game canvas"></canvas>
    <div id="ui">
      <div id="topbar">
        <div id="wave">Wave 1</div>
        <div id="ants">Ants: 0</div>
        <div id="hp">Cake: 3</div>
      </div>
      <button id="startBtn" class="btn">Tap to Start</button>
      <div id="hint">Protect the cake. Tap ants before they reach the center.</div>
      <div id="toast" class="toast" role="status" aria-live="polite"></div>
    </div>
    <div id="debug">[init] JS loaded
</div>
  </div>
  <script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => navigator.serviceWorker.register('sw.js'));
  }
  </script>
  <script>
  (() => {
    const debug=document.getElementById('debug');const log=(...a)=>{if(debug){debug.textContent+=a.join(' ')+'\n';}console.log('[Ants]',...a);};window.onerror=(m,s,l,c,e)=>{log('ERROR:',m,'@',s,l+':'+c)};
    const DPR = Math.min(3, window.devicePixelRatio || 1);
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: false });
    const startBtn = document.getElementById('startBtn');
    const waveEl = document.getElementById('wave');
    const antsEl = document.getElementById('ants');
    const hpEl = document.getElementById('hp');
    const toast = document.getElementById('toast');

    // FIX: declare arenaRadius BEFORE it's ever assigned in resize()
    let W = 0, H = 0, CX = 0, CY = 0;
    let arenaRadius = 0;

    function resize() {
      W = Math.floor(window.innerWidth);
      H = Math.floor(window.innerHeight);
      CX = W * 0.5;
      CY = H * 0.5;
      canvas.width = W * DPR;
      canvas.height = H * DPR;
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      arenaRadius = Math.min(W, H) * 0.42;
      log('resize', W, H, 'arena', arenaRadius.toFixed(1));
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    let running = false;
    let gameOver = false;
    let wave = 1;
    let cakeHP = 3;

    const ants = [];
    const ANT_RADIUS = 14;
    const TAP_RADIUS = 28;

    function reset() {
      running = true;
      gameOver = false;
      wave = 1;
      cakeHP = 3;
      ants.length = 0;
      spawnWave(wave);
      updateHUD();
      log('reset -> wave', wave, 'ants', ants.length);
    }

    function spawnWave(n) {
      const count = n === 1 ? 10 : Math.floor(10 + (n-1) * 1.5);
      for (let i = 0; i < count; i++) ants.push(makeAnt());
    }

    function makeAnt() {
      const angle = Math.random() * Math.PI * 2;
      const spawnR = arenaRadius + 40 + Math.random() * 30;
      const x = CX + Math.cos(angle) * spawnR;
      const y = CY + Math.sin(angle) * spawnR;
      const speed = 70 + Math.random() * 40 + wave * 6;
      return { x, y, angle, speed, alive: true };
    }

    function updateHUD() {
      waveEl.textContent = `Wave ${wave}`;
      antsEl.textContent = `Ants: ${ants.filter(a => a.alive).length}`;
      hpEl.textContent = `Cake: ${cakeHP}`;
    }

    function handlePointer(e) {
      const rect = canvas.getBoundingClientRect();
      const px = (e.clientX - rect.left);
      const py = (e.clientY - rect.top);
      log('tap', Math.round(px), Math.round(py), 'running', running, 'gameOver', gameOver);
      if (!running || gameOver) return;
      let hit = false;
      for (const a of ants) {
        if (!a.alive) continue;
        const dx = a.x - px;
        const dy = a.y - py;
        if (dx*dx + dy*dy <= (TAP_RADIUS*TAP_RADIUS)) { a.alive = false; hit = true; }
      }
      if (hit) showToast('Splat!');
      updateHUD();
    }
    canvas.addEventListener('pointerdown', (e) => { e.preventDefault(); handlePointer(e); }, { passive: false });

    startBtn.addEventListener('click', () => {
      log('startBtn click', 'running', running, 'gameOver', gameOver);
      if (!running && !gameOver) {
        startBtn.style.display = 'none';
        reset();
      } else if (gameOver && cakeHP > 0) {
        gameOver = false;
        running = true;
        spawnWave(wave += 1);
        updateHUD();
        startBtn.style.display = 'none';
      } else if (gameOver && cakeHP <= 0) {
        startBtn.style.display = 'none';
        reset();
      }
    });

    let last = performance.now();
    function frame(now) {
      const dt = Math.min(0.03, (now - last) / 1000);
      last = now;

      drawBackground();

      ctx.strokeStyle = '#2a2a2a';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(CX, CY, arenaRadius, 0, Math.PI * 2);
      ctx.stroke();

      drawCake();

      if (running && !gameOver) {
        for (const a of ants) {
          if (!a.alive) continue;
          const dx = CX - a.x;
          const dy = CY - a.y;
          const len = Math.hypot(dx, dy) || 1;
          const vx = (dx / len) * a.speed * dt;
          const vy = (dy / len) * a.speed * dt;
          a.x += vx;
          a.y += vy;

          const distToCenter = Math.hypot(a.x - CX, a.y - CY);
          if (distToCenter <= 36) {
            a.alive = false;
            cakeHP -= 1;
            showToast('They got a bite!');
            if (cakeHP <= 0) {
              gameOver = true;
              running = false;
              startBtn.textContent = 'Restart';
              startBtn.style.display = 'block';
            }
          }
        }

        const aliveCount = ants.filter(a => a.alive).length;
        if (aliveCount === 0 && cakeHP > 0) {
          gameOver = true;
          running = false;
          startBtn.textContent = 'Next Wave';
          startBtn.style.display = 'block';
          showToast('Wave cleared');
        }
        updateHUD();
      }

      for (const a of ants) {
        if (!a.alive) continue;
        drawAnt(a);
      }

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    function drawBackground() {
      ctx.fillStyle = '#101114';
      ctx.fillRect(0, 0, W, H);
      ctx.globalAlpha = 0.06;
      for (let i = 0; i < 12; i++) {
        ctx.fillStyle = i % 2 ? '#1a1c1f' : '#15171a';
        ctx.fillRect(0, i * (H / 12), W, H / 12);
      }
      ctx.globalAlpha = 1;
    }

    function drawCake() {
      const r = 28;
      ctx.fillStyle = '#e0e0e0';
      ctx.beginPath(); ctx.arc(CX, CY, r + 10, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#f7c4c4';
      ctx.beginPath(); ctx.arc(CX, CY, r, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = '#b84a4a';
      ctx.lineWidth = 3;
      ctx.beginPath();
      for (let i = 0; i <= 16; i++) {
        const ang = (i / 16) * Math.PI * 2;
        const rr = r + Math.sin(i * 0.7) * 2;
        const x = CX + Math.cos(ang) * rr;
        const y = CY + Math.sin(ang) * rr;
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.closePath(); ctx.stroke();
    }

    function drawAnt(a) {
      const body = ANT_RADIUS;
      ctx.fillStyle = '#2b2b2b';
      ctx.beginPath();
      ctx.ellipse(a.x, a.y, body * 0.55, body * 0.4, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(a.x + Math.cos(a.angle) * 10, a.y + Math.sin(a.angle) * 10, body * 0.25, body * 0.22, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#3a3a3a';
      ctx.lineWidth = 2;
      for (let i = -1; i <= 1; i++) {
        ctx.beginPath();
        ctx.moveTo(a.x - 8, a.y + i * 6);
        ctx.lineTo(a.x - 14, a.y + i * 10);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(a.x + 8, a.y + i * 6);
        ctx.lineTo(a.x + 14, a.y + i * 10);
        ctx.stroke();
      }
    }

    let toastTimer = 0;
    function showToast(msg) {
      toast.textContent = msg;
      toast.classList.add('show');
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => toast.classList.remove('show'), 600);
      log('toast:', msg);
    }
  })();
  </script>
</body>
</html>
